# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Tauri plugin for camera management with streaming capabilities. The plugin follows the standard Tauri plugin architecture with:
- Rust backend for both desktop and mobile platforms
- TypeScript/JavaScript guest API for frontend integration
- Cross-platform support (desktop: Windows/macOS/Linux, mobile: iOS/Android)

## Build Commands

### JavaScript/TypeScript API
```bash
# Build the guest-js API (creates dist-js/)
pnpm build

# Development workflow (auto-builds before publish/test)
pnpm prepare
```

### Rust Plugin
```bash
# Build the plugin
cargo build

# Build for release
cargo build --release

# Run tests
cargo test
```

### Example Application
```bash
# Navigate to example
cd examples/tauri-app

# Install dependencies
pnpm install

# Run dev server
pnpm tauri dev

# Build example app
pnpm tauri build
```

## Architecture

### Plugin Structure

The plugin uses conditional compilation for platform-specific implementations:

- **[src/lib.rs](src/lib.rs)**: Main entry point, exports `init()` function and `CameraExt` trait
- **[src/desktop.rs](src/desktop.rs)**: Desktop implementation (`#[cfg(desktop)]`)
- **[src/mobile.rs](src/mobile.rs)**: Mobile implementation (`#[cfg(mobile)]`) with iOS/Android bindings
- **[src/commands.rs](src/commands.rs)**: Tauri command handlers (currently just `ping`)
- **[src/models.rs](src/models.rs)**: Shared data structures between frontend and backend
- **[src/error.rs](src/error.rs)**: Error types with `thiserror` and Serde serialization

### Platform-Specific Patterns

The plugin automatically switches between desktop and mobile implementations at compile time:

```rust
#[cfg(desktop)]
use desktop::Camera;
#[cfg(mobile)]
use mobile::Camera;
```

**Desktop**: `Camera` wraps `AppHandle<R>` and implements logic directly in Rust

**Mobile**: `Camera` wraps `PluginHandle<R>` and delegates to native Swift (iOS) or Kotlin (Android) code via `run_mobile_plugin()`

### Extension Trait Pattern

The plugin provides the `CameraExt` trait to access camera APIs from any Tauri `Manager` (App, AppHandle, Window):

```rust
use tauri_plugin_camera::CameraExt;

#[tauri::command]
fn some_command(app: AppHandle) {
    let camera = app.camera();  // Access via extension trait
    // Use camera...
}
```

### Guest API (TypeScript)

The [guest-js/index.ts](guest-js/index.ts) file provides the frontend API. It uses Tauri's `invoke()` with the plugin namespace:

```typescript
invoke<Response>('plugin:camera|command_name', { payload })
```

Built with Rollup to generate CJS and ESM bundles in `dist-js/`.

## Permissions System

Permissions are defined in [permissions/default.toml](permissions/default.toml). Auto-generated command permissions are in `permissions/autogenerated/`.

Current permissions:
- `allow-ping`: Allows the ping command

To use the plugin, apps must include the permission set in their capabilities configuration.

## Development Notes

### Adding New Commands

1. Define request/response types in [src/models.rs](src/models.rs)
2. Add command handler in [src/commands.rs](src/commands.rs)
3. Implement platform-specific logic in `desktop.rs` and/or `mobile.rs`
4. Add command to handler in [src/lib.rs](src/lib.rs): `tauri::generate_handler![commands::your_command]`
5. Export TypeScript function in [guest-js/index.ts](guest-js/index.ts)
6. Add permission in [permissions/default.toml](permissions/default.toml)
7. Build with `pnpm build`

### Mobile Platform Implementation

For iOS: Implement Swift plugin class and bind with `tauri::ios_plugin_binding!` macro

For Android: Implement Kotlin plugin class (referenced in `mobile.rs` `register_android_plugin` call)

Mobile commands go through the `PluginHandle::run_mobile_plugin()` bridge instead of being handled directly in Rust.

## Project Goal

The primary objective is to enable **camera streaming** from frontend or Rust code using the **CrabCamera library** as the underlying camera management system.

## CrabCamera Integration

This plugin uses CrabCamera as a library dependency for cross-platform camera management. CrabCamera handles the low-level camera access and streaming across different platforms.

### Adding CrabCamera Dependency

Add to [Cargo.toml](Cargo.toml):

```toml
[dependencies]
crabcamera = { path = "../crabcamera" }  # Or from git
tokio = { version = "1.40", features = ["full"] }
```

Optional features:
```toml
[dependencies.crabcamera]
path = "../crabcamera"
features = ["audio", "recording", "webrtc"]  # Enable as needed
```

### CrabCamera Core Types

```rust
use crabcamera::{
    PlatformCamera,        // Main camera interface
    CameraSystem,          // Device enumeration
    CameraInitParams,      // Configuration
    CameraFrame,           // Captured frame data
    CameraFormat,          // Video format (resolution, fps, etc.)
    CameraDeviceInfo,      // Device information
    CameraError,           // Error handling
    platform::optimizations, // Platform-specific optimal settings
};
```

### Key CrabCamera APIs

**List available cameras:**
```rust
let system = CameraSystem::new();
let devices = system.list_devices()?;
```

**Initialize camera:**
```rust
let params = CameraInitParams::new(device_id)
    .with_format(optimizations::get_optimal_settings().format.unwrap())
    .with_auto_focus(true)
    .with_auto_exposure(true);

let camera = PlatformCamera::new(params)?;
```

**Start streaming:**
```rust
camera.start_streaming(Box::new(|frame: CameraFrame| {
    // Process each frame
    println!("Frame: {}x{} - {} bytes", frame.width, frame.height, frame.data.len());
})).await?;
```

**Capture single frame:**
```rust
let frame = camera.capture_frame().await?;
```

**Stop streaming:**
```rust
camera.stop_stream()?;
```

### Integration Pattern for This Plugin

The recommended approach is to wrap CrabCamera in the desktop implementation:

1. Store `PlatformCamera` instances in plugin state (using `Arc<AsyncMutex<PlatformCamera>>`)
2. Use CrabCamera's streaming callback to forward frames to Tauri channels
3. Map `CameraError` to the plugin's error types
4. Expose CrabCamera's device enumeration through plugin commands

Example integration in [src/desktop.rs](src/desktop.rs):

```rust
use crabcamera::{PlatformCamera, CameraInitParams, CameraFrame};
use std::sync::Arc;
use tokio::sync::Mutex as AsyncMutex;
use std::collections::HashMap;

pub struct Camera<R: Runtime> {
    app: AppHandle<R>,
    cameras: Arc<AsyncMutex<HashMap<String, Arc<AsyncMutex<PlatformCamera>>>>>,
}

impl<R: Runtime> Camera<R> {
    pub async fn start_streaming(&self, device_id: String, on_frame: Channel<FrameEvent>) -> Result<()> {
        let params = CameraInitParams::new(device_id.clone())
            .with_format(crabcamera::platform::optimizations::get_optimal_settings().format.unwrap());

        let camera = PlatformCamera::new(params)
            .map_err(|e| Error::CameraError(e.to_string()))?;

        camera.start_streaming(Box::new(move |frame: CameraFrame| {
            let event = FrameEvent {
                data: frame.data,
                width: frame.width,
                height: frame.height,
            };
            let _ = on_frame.send(event);
        })).await.map_err(|e| Error::CameraError(e.to_string()))?;

        let mut cameras = self.cameras.lock().await;
        cameras.insert(device_id, Arc::new(AsyncMutex::new(camera)));

        Ok(())
    }
}
```

### Streaming to Frontend with Tauri Channels

Use Tauri's channel system to stream frames efficiently:

```rust
#[derive(Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct FrameEvent {
    #[serde(with = "serde_bytes")]
    pub data: Vec<u8>,
    pub width: u32,
    pub height: u32,
    pub timestamp_ms: u64,
}

#[command]
pub async fn stream_camera(
    device_id: String,
    on_frame: Channel<FrameEvent>,
    app: AppHandle<R>,
) -> Result<String> {
    app.camera().start_streaming(device_id, on_frame).await
}
```

Frontend usage:
```typescript
import { Channel } from '@tauri-apps/api/core';

const onFrame = new Channel<FrameEvent>();
onFrame.onmessage = (frame) => {
    // Render frame to canvas
    renderFrame(frame.data, frame.width, frame.height);
};

await invoke('plugin:camera|stream_camera', {
    deviceId: '0',
    onFrame
});
```

### CrabCamera Platform Optimizations

CrabCamera provides platform-specific optimal settings:

```rust
use crabcamera::platform::optimizations;

// For general streaming
let optimal = optimizations::get_optimal_settings();

// For photography/high quality
let photo_format = optimizations::get_photography_format();
```

## Related Documentation

See [PLUGIN_DEPENDENCY_GUIDE.md](PLUGIN_DEPENDENCY_GUIDE.md) for detailed CrabCamera usage examples and patterns.
